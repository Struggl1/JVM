# **JVM**

## 一、JVM架构模型

	由于跨平台性的设计，java的指令都是根据栈设计的

	栈：跨平台性、指令集小，但是指令多，编译器容易实现，缺点是性能下降，实现同样多的功能需要更多的指令。执行性能比寄存器差。

## 二、JVM的生命周期

### 1、虚拟机的启动

	java虚拟机的启动是通过引导类加载器创建一个初始类来引导的，这个类由虚拟机的具体实现指定的。

### 2、虚拟机的执行

	程序开始执行时执行，程序结束时停止，在执行java程序的时候，实际上是执行java虚拟机的进程

### 3、虚拟机的退出

	程序正常执行结束

	程序执行过程中遇到异常或错误而异常终止

	操作系统出现错误，导致java虚拟机进程结束

	线程调用Runtime类或者System的exit方法，或者是Runtime类的halt方法，并且java管理器允许这次exit或halt操作

## 三、类加载过程

	**加载>>>>链接（验证>>准备>>解析）>>>>初始化**

	1、初始化，初始化阶段就是执行类构造器方法<clinit>()的过程，此方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中语句合并而来

	2、<clinit>()不同于类的构造器，构造器是虚拟机视角下的init(),若该类具 有父类，JVM会保证执行子类的<clinit>()方法之前执行父类的<clinit>()已经执行完毕

	3、虚拟机必须保证一个类的<clinit>()在多线程下被同步加锁

### 	①、虚拟机栈

常见问题：

1、java虚拟机允许java栈的大小是动态的或者是固定不变的

        如果采用固定大小的java虚拟机栈，如果线程请求分配的栈容量超过java虚拟机允许的最大容量，就会出现							               					StackOverflowError

        如果java虚拟机栈可扩展，并且在尝试扩展的时候无法申请到足够的内存，或者是创建新线程的时候，没有足够的内存去创					建虚拟机栈，就会出现OutOfMemoryError异常

        使用-Xss选项来设置线程的最大栈空间

2、栈帧的结构

    局部变量表
        局部变量表所需容量的大小是在编译器确定下来的，

        局部变量表最基本的单位是槽（slot），32位以内的类型占一个slot（包含returnAddress医用类型），64位的类型
            （Long，Double）占用两个slot。如果当前帧是由构造方法或者是实体方法创建的，那么该对象引用的this将会存放在
            index为0的slot处，其余参数按照参数表顺序进行排列。静态方法是不会创建this的，所以静态 方法是不能使用this的。
            局部变量表中的槽位是可以重复利用的

    操作数栈

    

    动态链接

    方法返回地址

    一些附加信息

JIT编译器有两种编译器：
c1和c2，c1是client端，c1优化主要是方法内内联，去虚拟化，冗余消除
c2是server端
逃逸分析是jvm优化的基础：
    标量替换：使用标量值代替使用的对象
    栈上分配：对于未逃逸的对象分配在栈上，而不是堆上
    同步消除：消除同步操作，一般指的是synchronized


